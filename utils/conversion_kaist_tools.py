"""
KAIST Pedestrian Detection Benchmark has the following directory structure:

kaist-pedestrian/
    |-> images/
    |   |-> set00/
    |   |   |-> V000/
    |   |   |   |-> I00000.jpg
    |   |   |   |-> I00001.jpg
    |   |   |   |-> ...
    |   |   |-> V001/
    |   |   |-> ...
    |   |-> set01/
    |   |-> ...
    |-> annotations-vbb/
    |   |-> set00/
    |   |   |-> V000.vbb
    |   |   |-> V001.vbb
    |   |   |-> ...
    |   |-> set01/
    |   |-> ...
    |-> annotations-xml/ # generated by `kaist_to_voc_format.py` script
    |   |-> set00/
    |   |   |-> V000/
    |   |   |   |-> I00000.xml
    |   |   |   |-> I00001.xml
    |   |   |   |-> ...
    |   |   |-> V001/
    |   |   |-> ...
    |   |-> set01/
    |   |-> ...
    |-> annotations-json/ # generated by `kaist_to_coco_format.py` script (this script)
    |   |-> kaist_annotations.json

kaist_to_voc_format.py script converts the annotations to xml files in PASCAL VOC format. each frame is a xml file containing the bounding boxes of the objects in the frame. The directory structure is as follows:

"""

import os, glob
from scipy.io import loadmat
from collections import defaultdict
import numpy as np
import json
import os 
from pathlib import Path
from tqdm.auto import tqdm

import pdb

IMAGE_SIZE = (640, 512)     # KAIST Multispectral Benchmark

def vbb_anno2dict(vbb_file, sub_dir):
    vid_name = os.path.splitext(os.path.basename(vbb_file))[0]
    annos = defaultdict(dict)
    vbb = loadmat(vbb_file)
    # object info in each frame: id, pos, occlusion, lock, posv

    objLists = vbb['A'][0][0][1][0]
    objLbl = [str(v[0]) for v in vbb['A'][0][0][4][0]]

    nFrame = int(vbb['A'][0][0][0][0][0])    
    maxObj = int(vbb['A'][0][0][2][0][0])
    objInit = vbb['A'][0][0][3][0]
    
    # objStr = vbb['A'][0][0][5][0]
    # objEnd = vbb['A'][0][0][6][0]
    # objHide = vbb['A'][0][0][7][0]
    # altered = int(vbb['A'][0][0][8][0][0])
    # log = vbb['A'][0][0][9][0]
    # logLen = int(vbb['A'][0][0][10][0][0])

    # objLists = vbb['A'][0][0][1][0]
    # objLbl = [str(v[0]) for v in vbb['A'][0][0][4][0]]
    # person index
    # person_index_list = np.where(np.array(objLbl) == "person")[0]
    
    for frame_id, obj in enumerate(objLists):
        
        frame_name = '/'.join( [sub_dir, vid_name, 'I{:05d}'.format(frame_id)] )
        annos[frame_name] = defaultdict(list)
        annos[frame_name]["id"] = frame_name            
                    
        if len(obj[0]) > 0:                
            for id, pos, occl, lock, posv in zip(
                        obj['id'][0], obj['pos'][0], obj['occl'][0],
                        obj['lock'][0], obj['posv'][0]):

                id = int(id[0][0]) - 1  # for matlab start from 1 not 0
                pos = pos[0].tolist()
                occl = int(occl[0][0])
                lock = int(lock[0][0])
                posv = posv[0].tolist()                

                annos[frame_name]["label"].append(objLbl[id])
                annos[frame_name]["occlusion"].append(occl)
                annos[frame_name]["bbox"].append(pos)
        """
        returns annotations in the following format:
        annos = {
            "set00/V000/I00000"(image_id)]: {
                "label":[],
                "occlusion":[],
                "bbox":[]
            },
            ...
        }
        
        """                     
    return annos


def get_per_frame_annotations(per_frame_anns : dict,
                                img_size : tuple,
                                bbox_type : str = 'xywh',
                                _img_id : int = None,
                                _ann_id: int = None,
                                _categories : list = None) -> tuple[dict, list, list]:
    
    """
    Gets a frame's annotations and returns them in COCO format (image, annotations)
    each frame is associated with multiple or no annotations. extract them and return them in COCO format
    Args:
        per_frame_anns (dict): annotations for a frame
        img_size (tuple): image size
        bbox_type (str, optional): bbox type. Defaults to 'xywh'.
        _img_id (int): image id. Defaults to 0.
        _ann_id (int): annotation id. Defaults to 0.
    Returns:
        tuple[dict, list]: image, annotations

    bbox_type: xyxy (xmin, ymin, xmax, ymax); xywh (xmin, ymin, width, height)
    
    """

    assert bbox_type in ['xyxy', 'xywh'], "bbox_type must be xyxy or xywh"


    image = {
        "id": int(_img_id),
        "file_name": str(per_frame_anns["id"]),
        "width": int(img_size[0]),
        "height": int(img_size[1]),
        "date_captured": "2015",
        "depth": 4,
        "segmentated": 0
    }

    annotations=[]

    def get_category_id(label):
        # if category exit return it else create one
        if str(label).strip() in _categories:
            return _categories.index(str(label).strip()) + 1
        else:
            _categories.append(str(label).strip())
            return len(_categories)


    for index, bbox in enumerate(per_frame_anns['bbox']):
        ann ={}
        ann["id"] = _ann_id + index
        ann["image_id"] = _img_id
        ann["segmentation"] = []
        ann["iscrowd"] = 0
        ann["score"] = 1
        ann["oclusion"] = per_frame_anns["occlusion"][index]
        ann["truncation"] = 0
        ann["pose"] = "unknown"
        ann["difficult"] = 0

        bbox = [float(x) for x in bbox]
        if bbox_type == 'xyxy':
            xmin, ymin, w, h = bbox
            xmax = xmin+w
            ymax = ymin+h
        else:
            xmin, ymin, xmax, ymax = bbox

        ann["bbox"] = [xmin, ymin, xmax, ymax]
        ann["area"] = bbox[2] * bbox[3]

        category_id = get_category_id(per_frame_anns["label"][index])
        ann["category_id"] = category_id

        annotations.append(ann)
        
    return (image, _categories, annotations)

def convert_kaist_to_coco(vbb_inputdir):
    # annotation sub-directories in hda annotation input directory
    assert os.path.exists(vbb_inputdir), "vbb_inputdir does not exist"
    sub_dirs = os.listdir(vbb_inputdir)


    kaist_coco_format = {
        "info": {
            "description": "KAIST Multispectral Ped Benchmark",
            "url": "https://soonminhwang.github.io/rgbt-ped-detection/",
            "version": "v1.0",
            "year": 2015,
            "contributor": "KAIST Multispectral Ped Benchmark Group",
            "date_created": "2015"
        },
        "licenses": [],
        "images": [],
        "annotations": [],
        "categories": []
    }

    
    for sub_dir in tqdm(sub_dirs):
        print( "Parsing annotations (vbb): {}".format(sub_dir) )        
        vbb_files = glob.glob(os.path.join(vbb_inputdir, sub_dir, "*.vbb"))
        
        _current_img_id = 1
        _current_annotation_id = 1

        _categories = []

        for vbb_file in vbb_files:            
            annos = vbb_anno2dict(vbb_file, sub_dir)
            if annos:                
                # vbb_outdir = os.path.join(vbb_outputdir, sub_dir, os.path.basename(vbb_file).split('.')[0])
                # print( "vbb_outdir: {}".format(vbb_outdir) )
                
                # if not os.path.exists(vbb_outdir):
                #     os.makedirs(vbb_outdir)

                for filename, per_frame_dict in sorted(annos.items(), key=lambda x: x[0]):
                    # if "bbox" in anno:
                    # print(f"[DEBUGGING] box: {anno['bbox']}")
                    image, _updated_categories, annotations = get_per_frame_annotations(per_frame_anns=per_frame_dict,
                                                                  img_size=IMAGE_SIZE,
                                                                  bbox_type='xywh',
                                                                  _img_id=_current_img_id,
                                                                  _ann_id=_current_annotation_id,
                                                                  _categories=_categories)
                    _categories = _updated_categories
                    kaist_coco_format["images"].append(image)
                    kaist_coco_format["annotations"].extend(annotations)                       

                    _current_img_id += 1
                    _current_annotation_id += len(annotations)
        kaist_coco_format["categories"] = [{"id": i+1, "name": cat} for i, cat in enumerate(_categories)]

    return kaist_coco_format